/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include "r.h"

int *
init_1_svc(struct svc_req *rqstp) {
	
	static int  result;
	result = 0;
	/* It would be easier to just do rm database/* 
	 but it is imterpretred as the start of a comment by the compiler */
	result= system("exec rm -r database"); 
	
	//printf("%d", result);
	system("exec mkdir database");
	printf("init \n");

	return &result;
}
//26
int *
register_1_svc(char *user,  struct svc_req *rqstp)
{
	static int  result;
	result = 0;
	
	printf("Register %s \n", user);
	
	int name_size = strlen("database/") + strlen(user);
	char file_name[name_size];

	sprintf(file_name, "database/%s", user);
	

	int fd;
	
	if ((fd = open(file_name, O_WRONLY|O_CREAT|O_APPEND, 0666)) == -1) {
		result = -1;
		return FALSE;
	}

	close(fd);




	

	return &result;
}

int *
unregister_1_svc(char *user,  struct svc_req *rqstp)
{
	static int  result;
	result = 0;
	//Allocate buffer 
	int name_size = strlen("database/") + strlen(user);
	char file_name[name_size];
	//Construct name
	sprintf(file_name, "database/%s", user);
	//Execute command 
	result= remove(file_name);
 	if(result == 0) {
   	   printf("User %s unregistered succesfully ", user );
   	} else {
    	   printf("User %s doesn't exist ",user);
  	 }

	return &result;
}

int *
store_1_svc(char *sender, char *receiver, int id , char *text, char *md5, char *path, struct svc_req *rqstp)
{
	static int  result;
	result = 0;
	int name_size = strlen("database/") + strlen(sender);
	int line_size = strlen(receiver) + strlen(text) + strlen(path) + strlen(md5) + sizeof(id) + 4; // for EoL
	char file_name[name_size];
	char line[line_size];

	sprintf(file_name, "database/%s", sender);
	sprintf(line, "%d,%s,%s,%s,%s\n", id, receiver, text, md5, path);

	int fd;
	int written = 0, to_write = line_size;

	if ((fd = open(file_name, O_WRONLY|O_CREAT|O_APPEND, 0666)) == -1) {
		result = -1;
		return FALSE;
	}

	while (to_write > 0 && written >=0) {
		written = write(fd, (char *) line + (line_size - to_write), to_write);
		to_write -= written;
	}

	if (written == -1) result = -1; // Error on write
	else result = 0;

	close(fd);

	return &result;
}

int *
msg_count_1_svc(char *user,  struct svc_req *rqstp)
{
	static int  result;
	

	int  name_size = strlen("database/") + strlen(user);
	char file_name[name_size];
	sprintf(file_name, "database/%s", user);

	FILE *fp = fopen(file_name,"r");
  	int ch=0;
  	int lines=0;

	while(!feof(fp))
	{
 	 ch = fgetc(fp);
  	if(ch == '\n')  // End of line found
  	{
  	  lines++;
  	}
	result = lines;

}

	return &result;
}



query_msg *
query_1_svc(char *user, char *arg2,  struct svc_req *rqstp)
{
	static query_msg  result;
	int fd, attr_n = 0, found = 0, last_read, idx = 0, name_size = strlen("database/") + strlen(user);
	char buffer = 32, file_name[name_size], field[256];

	sprintf(file_name, "database/%s", user);
	bzero(field, 256);


	if ((fd = open(file_name, O_RDONLY)) == -1) return FALSE;

	while ((last_read = read(fd, &buffer, 1)) >= 0) {
		if (buffer == EOF) break;
		if (last_read == 0) continue; // No se ha leido nada, probar otra vez.

		if (buffer == ',') {
			if (attr_n == 0 && !strcmp(field, arg2)) found = 1;
			if (attr_n == 2 && found) {
				result.msg = malloc(strlen(field));
				strcpy(result.msg, field);
			}
			bzero(field, 256);
			attr_n++;
			idx = 0;
			continue;
		} else if (buffer == '\n') {
			if (found) {
				result.md5 = malloc(strlen(field));
				strcpy(result.md5, field);
				break;
			}
			bzero(field, 256);
			attr_n = 0;
			idx = 0;
			continue;
		}

		field[idx] = buffer;
		idx ++;
	}

	if (!found) {
		result.msg = "";
		result.md5 = "";
	}
	close(fd);

	return &result;
}
